## 前言

以下题目是有60%是我以前面试前端真的遇到的面试题。例如，成都的字节，阿里，北京的阿里，腾讯还有一些中小公司。

## 如需要简单补一下计算机组成原理，请看我之前的文章
[【重磅升级！】写给前端非科班的「计算机组成原理」！！！](https://juejin.cn/post/6990652014862532622)

感谢star,是我完善文档的动力

## 什么是补码？有什么用？(成都字节)

补码是计算机中用来表示负数的一种方法。在计算机中，所有的数据都是以二进制的形式存储的，而补码就是一种将负数转化为二进制的方法。

在补码表示法中，正数的补码与其二进制表示形式相同。负数的补码由对应正数的补码按位取反（即0变为1，1变为0），然后再加1得到。这种表示方式使得负数的加法与正数的加法可以使用相同的硬件电路进行计算，简化了计算机的设计。


举例：
在JavaScript中，可以使用按位非(~)运算符来实现取反操作，使用按位与(&)运算符来实现加1操作。以下是一个实现减法运算的例子：

```javascript
function subtract(a, b) {
  b = ~b + 1;
  return a + b;
}
```

## 一个中文占多少字节？这个跟编码有什么关系？Unicode跟编码有什么关系？js是什么编码？（北京阿里）

一个中文字符占用多少字节跟编码密切相关，不能直接说一个中文占2个或者3个字节，比如UTF-8编码下一个中文字符占用3个字节。

Unicode是一种字符集，它定义了每个字符对应的唯一编号，但是并没有规定如何存储这些字符。编码则是将字符集中的字符转换为字节序列的方法。

在JavaScript中，通常使用UTF-16编码。



## 为什么0.1 + 0.2不等于0.3？请结合IEEE标准来说，如何避免这种计算误差 （深圳腾讯）

在计算机中，浮点数的表示采用的是IEEE 754标准。在这个标准中，浮点数被表示为一个符号位、一个阶码和一个尾数的组合。

其中，符号位表示正负，阶码表示指数，尾数表示小数部分。对于单精度浮点数，符号位占1位，阶码占8位，尾数占23位。对于双精度浮点数，符号位占1位，阶码占11位，尾数占52位。

在IEEE 754标准中，浮点数的表示是有限的，而0.1和0.2在二进制下是无限循环小数。

因此，它们在转换为浮点数时会被截断为一个近似值。这个近似值与0.3的近似值不相等，因此0.1 + 0.2不等于0.3。

避免方法可以使用将数字转化为字符串，然后模拟加法运算，一些库就是这样实现的，可以完全避免出现误差。（千万别说可以用乘法转换为整数做运算，也一样会有误差）

也可以使用NumberFormat API(兼容IE11),完全可以用到生产环境
```
const nf = new Intl.NumberFormat('en-US', { minimumFractionDigits: 1 });
const result = nf.format(0.1 + 0.2);
console.log(result); // "0.3"
```

## 进制转换：任意进制如何转化为十进制（北京百度）

例如：2进制101.1如何转化为10进制。（有些同学觉得可以用parseInt('101.1', 2)，这个是不行的，因为parseInt返回整数）
转化方法如下（按权相加法）：
```
2进制的 101.1 = 1 x 22 + 0 x 21  + 1 x 20 + 1 x 2-1
```
规律就是二进制的每个数去乘以2的相应次方,注意小数点后是乘以它的负相应次方。


## 进制转换：十进制整数转为任意进制（北京百度）

例如：
把89化为二进制的数
```
89÷2=44 余1
44÷2=22 余0
22÷2=11 余0
11÷2=5 余1
5÷2=2 余1
2÷2=1 余0
1÷2=0 余1
```
然后把余数由下往上排序
`1011001`
这样就把89化为二进制的数了

## 进制转换：十进制小数转为n进制

我们还是以2进制为例，方式是采用“乘2取整，顺序排列”法。具体做法是：

- 用2乘十进制小数，可以得到积，将积的整数部分取出-
- 再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出-
- 如此进行，直到积中的小数部分为零，或者达到所要求的精度为止

所以n进制是一个道理
我们具体举一个例子
如: 十进制 0.25 转为二进制
```
0.25 * 2 = 0.5 取出整数部分：0
0.5 * 2 = 1.0 取出整数部分1
```
即十进制0.25的二进制为 0.01 ( 第一次所得到为最高位,最后一次得到为最低位)

