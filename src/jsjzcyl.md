## 前言

以下题目是有 60%是我以前面试前端真的遇到的面试题。例如，成都的字节，阿里，北京的阿里，腾讯还有一些中小公司。

## 如需要简单补一下计算机组成原理，请看我之前的文章

[【重磅升级！】写给前端非科班的「计算机组成原理」！！！](https://juejin.cn/post/6990652014862532622)

感谢 star,是我完善文档的动力

## 什么是补码？有什么用？(成都字节)

补码是计算机中用来表示负数的一种方法。在计算机中，所有的数据都是以二进制的形式存储的，而补码就是一种将负数转化为二进制的方法。

在补码表示法中，正数的补码与其二进制表示形式相同。负数的补码由对应正数的补码按位取反（即 0 变为 1，1 变为 0），然后再加 1 得到。这种表示方式使得负数的加法与正数的加法可以使用相同的硬件电路进行计算，简化了计算机的设计。

举例：
在 JavaScript 中，可以使用按位非(~)运算符来实现取反操作，使用按位与(&)运算符来实现加 1 操作。以下是一个实现减法运算的例子：

```javascript
function subtract(a, b) {
  b = ~b + 1;
  return a + b;
}
```

## 一个中文占多少字节？这个跟编码有什么关系？Unicode 跟编码有什么关系？js 是什么编码？（北京阿里）

一个中文字符占用多少字节跟编码密切相关，不能直接说一个中文占 2 个或者 3 个字节，比如 UTF-8 编码下一个中文字符占用 3 个字节。

Unicode 是一种字符集，它定义了每个字符对应的唯一编号，但是并没有规定如何存储这些字符。编码则是将字符集中的字符转换为字节序列的方法。

在 JavaScript 中，通常使用 UTF-16 编码。

## 为什么 0.1 + 0.2 不等于 0.3？请结合 IEEE 标准来说，如何避免这种计算误差 （深圳腾讯）

在计算机中，浮点数的表示采用的是 IEEE 754 标准。在这个标准中，浮点数被表示为一个符号位、一个阶码和一个尾数的组合。

其中，符号位表示正负，阶码表示指数，尾数表示小数部分。对于单精度浮点数，符号位占 1 位，阶码占 8 位，尾数占 23 位。对于双精度浮点数，符号位占 1 位，阶码占 11 位，尾数占 52 位。

在 IEEE 754 标准中，浮点数的表示是有限的，而 0.1 和 0.2 在二进制下是无限循环小数。

因此，它们在转换为浮点数时会被截断为一个近似值。这个近似值与 0.3 的近似值不相等，因此 0.1 + 0.2 不等于 0.3。

避免方法可以使用将数字转化为字符串，然后模拟加法运算，一些库就是这样实现的，可以完全避免出现误差。（千万别说可以用乘法转换为整数做运算，也一样会有误差）

也可以使用 NumberFormat API(兼容 IE11),完全可以用到生产环境

```
const nf = new Intl.NumberFormat('en-US', { minimumFractionDigits: 1 });
const result = nf.format(0.1 + 0.2);
console.log(result); // "0.3"
```

## 进制转换：任意进制如何转化为十进制（北京百度）

例如：2 进制 101.1 如何转化为 10 进制。（有些同学觉得可以用 parseInt('101.1', 2)，这个是不行的，因为 parseInt 返回整数）
转化方法如下（按权相加法）：

```
2进制的 101.1 = 1 x 22 + 0 x 21  + 1 x 20 + 1 x 2-1
```

规律就是二进制的每个数去乘以 2 的相应次方,注意小数点后是乘以它的负相应次方。

## 进制转换：十进制整数转为任意进制（北京百度）

例如：
把 89 化为二进制的数

```
89÷2=44 余1
44÷2=22 余0
22÷2=11 余0
11÷2=5 余1
5÷2=2 余1
2÷2=1 余0
1÷2=0 余1
```

然后把余数由下往上排序
`1011001`
这样就把 89 化为二进制的数了

## 进制转换：十进制小数转为 n 进制

我们还是以 2 进制为例，方式是采用“乘 2 取整，顺序排列”法。具体做法是：

- 用 2 乘十进制小数，可以得到积，将积的整数部分取出-
- 再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出-
- 如此进行，直到积中的小数部分为零，或者达到所要求的精度为止

所以 n 进制是一个道理
我们具体举一个例子
如: 十进制 0.25 转为二进制

```
0.25 * 2 = 0.5 取出整数部分：0
0.5 * 2 = 1.0 取出整数部分1
```

即十进制 0.25 的二进制为 0.01 ( 第一次所得到为最高位,最后一次得到为最低位)
