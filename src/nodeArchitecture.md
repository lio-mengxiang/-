
## Nodejs组成

Node.js主要由V8、Libuv和第三方库组成。

- Libuv：跨平台的异步IO库，但它提供的功能不仅仅是IO，还 包括进程、线程、信号、定时器、进程间通信，线程池等。

- 第三方库：异步DNS解析（cares）、HTTP解析器（旧版使用 http_parser，新版使用llhttp）、HTTP2解析器（nghttp2）、 解压压缩库(zlib)、加密解密库(openssl)等等。

- V8：实现JS解析和支持自定义的功能，得益于V8支持自定义拓展，才有了Node.js。

## Node.js代码架构

![image](https://user-images.githubusercontent.com/26076975/230293277-02d595c2-728d-414f-8efa-49ca4665c382.png)



上图是Node.js的代码架构，Node.js的代码主要分为JS、C++、C三种。

1 JS是我们使用的那些模块。

2 C++代码分为三个部分，第一部分是封装了Libuv的功能，第二部分则是不依赖于Libuv(crypto部分api使用了Libuv线程池)，比如Buffer模块。第三部分是V8的代码。

3 C语言层的代码主要是封装了操作系统的功能，比如TCP、UDP。

了解了Node.js的组成和架构后，我们看看Node.js启动的过程都做了什么。

## Node.js启动过程

### 1 注册C++模块

![image](https://user-images.githubusercontent.com/26076975/230291187-488467eb-1eba-480f-8387-41d43a24024c.png)

首先Node.js会调用registerBuiltinModules函数注册C++模块，这个函数会调用一系列registerxxx的函数，我们发现在Node.js源码里找不到这些函数，因为这些函数会在各个C++模块中，通过宏定义实现的。宏展开后就是上图黄色框的内容，每个registerxxx函数的作用就是往C++模块的链表了插入一个节点，最后会形成一个链表。

那么Node.js里是如何访问这些C++模块的呢？在Node.js中，是通过internalBinding访问C++模块的，internalBinding的逻辑很简单，就是根据模块名从模块队列中找到对应模块。但是这个函数只能在Node.js内部使用，不能在用户js模块使用。用户可以通过process.binding访问C++模块。


### 2 创建Environment对象，并绑定到Context

注册完C++模块后就开始创建Environment对象，Environment是Node.js执行时的环境对象，类似一个全局变量的作用，他记录了Node.js在运行时的一些公共数据。创建完Environment后，Node.js会把该对象绑定到V8的Context中，为什么要这样做呢？主要是为了在V8的执行上下文里拿到env对象，因为V8中只有Isolate、Context这些对象。如果我们想在V8的执行环境中获取Environment对象的内容，就可以通过Context获取Environment对象。

![image](https://user-images.githubusercontent.com/26076975/230292375-77e8de56-3f9c-400d-b1f2-13357fc18ed3.png)

### 3 初始化模块加载器

1 Node.js首先传入c++模块加载器，执行loader.js，loader.js主要是封装了c++模块加载器和原生js模块加载器。并保存到env对象中。

2 接着传入c++和原生js模块加载器，执行run_main_module.js。

3 在run_main_module.js中传入js和原生js模块加载器，执行用户的js。

假设用户js如下
```
require('net')
require('./myModule')
```
分别加载了一个用户模块和原生js模块，我们看看加载过程，执行require的时候。

1 Node.js首先会判断是否是原生js模块，如果不是则直接加载用户模块，否则，会使用原生模块加载器加载原生js模块。

2 加载原生js模块的时候，如果用到了c++模块，则使用internalBinding去加载。

![image](https://user-images.githubusercontent.com/26076975/230294426-3c930f54-3f0e-4c69-b4a9-2fd4429e1977.png)

### 4 执行用户JS代码，然后进入Libuv事件循环

接着Node.js就会执行用户的js，通常用户的js会给事件循环生产任务，然后就进入了事件循环系统，比如我们listen一个服务器的时候，就会在事件循环中新建一个tcp handle。Node.js就会在这个事件循环中一直运行。
```
net.createServer(() => {}).listen(80)
```
![image](https://user-images.githubusercontent.com/26076975/230295376-c1b3240d-1ff1-488c-ae19-0eaa576ebf0c.png)


#### 定时器阶段

此阶段执行由setTimeout和setInterval设置的回调。

Libuv 在底层里面维护了一个最小堆，每个定时节点就是堆里面的一个节点(Node.js 只用了 Libuv 的一个定时器节点)，越早超时的节点就在越上面。然后等到定时期阶段的时候， Libuv 就会从上往下去遍历这个最小堆判断当前节点有没有超时，如果没有到期的话，那么后面节点也不需要去判断了，因为最早到期的节点都没到期，那么它后面节点也显然不会到期。如果当前节点到期了，那么就会执行它的回调，并且把它移出这个最小堆。但是为了支持类似 setInterval 这种场景。如果这个节点设置了repeat 标记，那么这个节点它会被重新插入到最小堆中，等待下一次的超时。

#### peading阶段

虽然大部分 I/O 回调都是在 poll 阶段被立即执行，但是会存在一些被延迟调用的 I/O 回调函数。那么此阶段就是为了调用之前事件循环延迟执行的 I/O 回调函数。

#### idle\pewpare阶段

仅用于 nodejs 内部模块使用。

#### poll阶段

Poll IO是Libuv非常重要的一个阶段，文件IO、网络IO、信号处理等都在这个阶段处理，这也是最复杂的一个阶段。

poll 阶段的首要职责是：

- 计算因处理 I/O 需要阻塞当前事件循环 tick 的时间；该阻塞表示当前事件循环 tick 应该在当前 poll 阶段停留多久，这个时间一般是根据最小的 setTimeout/setInterval 的时间阈值等多个因素（见下文）来确定。在到达阻塞时间后，会经历当前事件循环 tick 的后续阶段，并最终进入下一个事件循环 tick 的 timer 阶段，此时，过期的计时器的回调函数得以执行。

- 处理事件回调。

接下来就要讨论什么时候会阻塞到这个截断，什么时候不阻塞。

不阻塞的条件：

当事件循环 tick 被 uv_stop()doc 函数标记为停止#时，返回 0，即不阻塞。

当事件循环 tick 不处于活动状态时且不存在活动的 request 时返回 0，即不阻塞。

当 idle 句柄队列不为空时，返回 0，即不阻塞。

当 pending callbacks 的回调队列不为空时，返回 0，即不阻塞。

当存在 closing 句柄，即存在 close 事件回调时，返回 0，即不阻塞。

在我看来，起码是有request，也就是有I/O事件不阻塞，有pending callbacks（我们上面已经提过pending callback了）不阻塞，close阶段和idle阶段的事件队列不为空也不做阻塞。

我们接着看什么时候阻塞：

若不存在任何计时器，那么当前事件循环 tick 中的 poll 阶段将 无限制阻塞。以实现一旦存在 I/O 回调函数加入到 poll queue 中即可立即得到执行。

若最近计时器时间节点小于等于开始时间，则表明在计时器二叉最小堆中 至少存在一个 过期的计时器，那么当前 poll 阶段的超时时间将被设置为 0，即表示 poll 阶段不发生阻塞。这是为了尽可能快的进入下一阶段，即尽可能快地结束当前事件循环 tick。在进入下一事件循环 tick 时，在 timer 阶段，上一 tick 中过期的计时器回调函数得以执行。

若最近计时器时间节点大于开始时间，则计算两个计时器之前的差值，且不大于 int 类型最大值。poll 将根据此差值来阻塞当前阶段，这么做是为了在轮询阶段，尽可能快的处理异步 I/O 事件。此时我们也可以理解为 事件循环 tick 始终有一种维持在 poll 阶段的倾向。

由以上源码分析，不难得出 poll 阶段的本质：

- 为了尽可能快的处理异步 I/O 事件，那么事件循环 tick 总有一种维持 poll 状态的倾向；

- 当前 poll 阶段应该维持（阻塞）多长时间是由 后续 tick 各个阶段是否存在不为空的回调函数队列 和 最近的计时器时间节点 决定。若所有队列为空且不存在任何计时器，那么事件循环将 无限制地维持在 poll 阶段。

> 注：因为 poll 阶段的超时时间在进入 poll 阶段之前计算，故当前 poll 阶段中回调函数队列中的计时器并不影响当前 poll 阶段的超时时间。



#### check阶段

check 阶段，用于在 poll 阶段的回调函数队列为空时，使用 setImmediate 实现调度执行特定代码片段。

该阶段的设计目的是可在 poll 阶段结束之时，立即调用指定代码片段（即函数）。

check 阶段的回调函数队列中所有的回调函数都是来自 poll 阶段的 setImmediate 函数。



#### close阶段
close 回调函数阶段，执行所有注册 close 事件的回调函数

此阶段用于执行所有的 close 事件的回调函数。如突然通过 socket.destroy() 关闭 socket 连接时，close 事件将在此阶段触发。

## 与浏览器实现对比

nodejs 与浏览器端的 Web API 版本的事件循环最大的不同的是：

在 nodejs 中事件循环不再是由单一个 task queue 和 micro-task queue 组成，而是由多个 阶段 phase 的多个回调函数队列 callbacks queues 组成一次事件循环 tick。 并且在每一个单独的阶段都存在一个单独的 回调函数 FIFO 队列。

而且实际上浏览器对事件队列的处理并不是仅仅按序执行event loop里的任务，而是分了优先级的，比如说用户的点击事件，键盘事件等等肯定要优先处理的，chrome内部就是分了多个队列然后排序优先级来处理event loop里产出的任务的。

##  Node.js 中的 Libuv

首先来看一下 Node.js 中的 Libuv，下面从三个方面介绍 Libuv。

1). 介绍 Libuv 的模型和限制

2). 介绍线程池解决的问题和带来的问题

3). 介绍事件循环

### Libuv 的模型和限制

Libuv 本质上是一个生产者消费者的模型。

![image](https://user-images.githubusercontent.com/26076975/230334489-5c2fb8ae-fc8a-42d2-b760-0b6d201ff1ed.png)

从上面这个图中，我们可以看到在 Libuv 中有很多种生产任务的方式，比如说在一个回调里，在 Node.js 初始化的时候，或者在线程池完成一些操作的时候，这些方式都可以生产任务。然后 Libuv 会不断的去消费这些任务，从而驱动着整个进程的运行，这就是我们一直说的事件循环。

但是生产者的消费者模型存在一个问题，就是消费者和生产者之间，怎么去同步?比如说在没有任务消费的时候，这个消费者他应该在干嘛?

第一种方式是消费者可以睡眠一段时间，睡醒之后，他会去判断有没有任务需要消费，如果有的话就继续消费，如果没有的话他就继续睡眠。很显然这种方式其实是比较低效的。

第二种方式是消费者会把自己挂起，也就是说这个消费所在的进程会被挂起，然后等到有任务的时候，操作系统就会唤醒它，相对来说，这种方式是更高效的，Libuv 里也正是使用这种方式。

这个逻辑主要是由事件驱动模块实现的，下面看一下事件驱动的大致的流程。

![image](https://user-images.githubusercontent.com/26076975/230334664-5f6d5003-2bc2-4969-92ae-e0b45e3ad43e.png)

但是生产者的消费者模型存在一个问题，就是消费者和生产者之间，怎么去同步?比如说在没有任务消费的时候，这个消费者他应该在干嘛?第一种方式是消费者可以睡眠一段时间，睡醒之后，他会去判断有没有任务需要消费，如果有的话就继续消费，如果没有的话他就继续睡眠。很显然这种方式其实是比较低效的。第二种方式是消费者会把自己挂起，也就是说这个消费所在的进程会被挂起，然后等到有任务的时候，操作系统就会唤醒它，相对来说，这种方式是更高效的，Libuv 里也正是使用这种方式。![image](https://user-images.githubusercontent.com/26076975/230334665-9deb8139-2a7b-4d6a-9c6f-d8bde5c3b0bb.png)

但是生产者的消费者模型存在一个问题，就是消费者和生产者之间，怎么去同步?比如说在没有任务消费的时候，这个消费者他应该在干嘛?第一种方式是消费者可以睡眠一段时间，睡醒之后，他会去判断有没有任务需要消费，如果有的话就继续消费，如果没有的话他就继续睡眠。很显然这种方式其实是比较低效的。第二种方式是消费者会把自己挂起，也就是说这个消费所在的进程会被挂起，然后等到有任务的时候，操作系统就会唤醒它，相对来说，这种方式是更高效的，Libuv 里也正是使用这种方式。

![image](https://user-images.githubusercontent.com/26076975/230336117-70fb06c0-7bcf-4ca4-9075-8dd4ae6c3c58.png)

应用层代码可以通过事件驱动模块订阅 fd 的事件，如果这个事件还没有准备好的话，那么这个进程就会被挂起。然后等到这个 fd 所对应的事件触发了之后，就会通过事件驱动模块回调应用层的代码。

但是 epoll 存在一些限制。首先第一个是不支持文件操作的，比方说文件读写，因为操作系统没有实现。第二个是不适合执行耗时操作，比如大量 CPU 计算、引起进程阻塞的任务，因为 epoll 通常是搭配单线程的，如果在单线程里执行耗时任务，就会导致后面的任务无法执行。


### 线程池解决的问题和带来的问题

针对这个问题，Libuv 提供的解决方案就是使用线程池。下面来看一下引入了线程池之后， 线程池和主线程的关系。

![image](https://user-images.githubusercontent.com/26076975/230336922-e11eb10e-030a-44ae-a379-214029bb09ae.png)

从这个图中我们可以看到，当应用层提交任务时，比方说像 CPU 计算还有文件操作，这种时候不是交给主线程去处理的，而是直接交给线程池处理的。线程池处理完之后它会通知主线程。

但是引入了多线程后会带来一个问题，就是怎么去保证上层代码跑在单个线程里面。因为我们知道 JS 它是单线程的，如果线程池处理完一个任务之后，直接执行上层回调，那么上层代码就会完全乱了。这种时候就需要一个异步通知的机制，也就是说当一个线程它处理完任务的时候，它不是直接去执行上程回调的，而是通过异步机制去通知主线程来执行这个回调。

这就是我们之前谈的poll阶段的作用，就是这行这些回调的。

## Node.js 中的 V8

下面从三个方面介绍 V8。

1. 介绍 V8 在 Node.js 的作用和 V8 的一些基础概念

2. 介绍如何通过 V8 执行 JS 和拓展 JS

3. 介绍如何通过 V8 实现 JS 和 C++ 通信

### V8 在 Node.js 的作用和基础概念

V8 在 Node.js 里面主要是有两个作用，第一个是负责解析和执行 JS。第二个是支持拓展 JS 能力，作为这个 JS 和 C++ 的桥梁。下面我们先来看一下 V8 里面那些重要的概念。

1. Isolate：首先第一个是 Isolate 它是代表一个 V8 的实例，它相当于这一个容器。通常一个线程里面会有一个这样的实例。比如说在 Node.js主线程里面，它就会有一个 Isolate 实例。

2. Context：Context 是代表我们执行代码的一个上下文，它主要是保存像 Object，Function 这些我们平时经常会用到的内置的类型。如果我们想拓展 JS 功能，就可以通过这个对象实现。

3. ObjectTemplate：ObjectTemplate 是用于定义对象的模板，然后我们就可以基于这个模板去创建对象。

4. FunctionTemplate：FunctionTemplate 和 ObjectTemplate 是类似的，它主要是用于定义一个函数的模板，然后就可以基于这个函数模板去创建一个函数。

5. FunctionCallbackInfo：用于实现 JS 和 C++ 通信的对象。

6. Handle：Handle 是用管理在 V8 堆里面那些对象，因为像我们平时定义的对象和数组，它是存在 V8 堆内存里面的。Handle 就是用于管理这些对象。

7. HandleScope：HandleScope 是一个 Handle 容器，HandleScope 里面可以定义很多 Handle，它主要是利用自己的生命周期管理多个 Handle。

下面我们通过一个代码来看一下 HandleScope 和 Handle 它们之间的关系。

![image](https://user-images.githubusercontent.com/26076975/230338259-6851ab6a-301e-4f7e-a84c-a3dc7815345d.png)

首先第一步新建一个 HandleScope，就会在一个栈里面定义一个 HandleScope 对象。然后第二步新建了一个 Handle 并且把它指向一个堆对象。这时候就会在栈里面分配一个叫 Local 对象，然后在堆里面分配一块 slot 所代表的内存和一个 Object 对象，并且建立关联关系。当执行完这个函数的时候，这个栈就会被清空，相应的这个 slot 代表的内存也会被释放，但是 Object 所代表这个对象，它是不会立马被释放的，它会等待 GC 的回收。


### 通过 V8 执行 JS 和拓展 JS

了解了 V8 的基础概念之后，来看一下怎么通过 V8 执行一段 JS 的代码

![image](https://user-images.githubusercontent.com/26076975/230338445-d508704b-7726-4a06-a657-ebec17758817.png)

首先第一步新建一个 Isolate，它这表示一个隔离的实例。第二步定义一个 HandleScope 对象，因为我们下面需要定义 Handle。第三步定义一个 Context，这是代码执行所在的上下文。第四步定义一些需要被执行的 JS 代码。第五步通过 Script 对象的 Compile 函数编译 JS 代码。编译完之后，我们会得到一个 Script 对象，然后执行这个对象的 Run 函数就可以完成代码的执行。

接下来再看一下怎么去拓展 JS 原有的一些能力。

![image](https://user-images.githubusercontent.com/26076975/230338641-55d8a480-a5ec-4362-ae66-e5d4d1e0bd1a.png)

首先第一步是通过 Context 上下文对象拿到一个全局的对象，类似于在前端里面的 window 对象。第二步通过 ObjectTemplate 新建一个对象的模板，然后接着会给这个对象模板设置一个 test 属性， 值是函数。接着通过这个对象模板新建一个对象，并且把这个对象设置到一个全局变量里面去。这样我们就可以在 JS 层去访问这个全局对象。

下面我们通过使用刚才定义那个全局对象来看一下 JS 和 C++ 是怎么通信的。

### 通过 V8 实现 JS 和 C++ 层通信

![image](https://user-images.githubusercontent.com/26076975/230338705-9e077172-2c36-40ae-95b8-dd7357687db2.png)

当在 JS 层调用刚才定义 test 函数时，就会相应的执行 C++ 层的 test 函数。这个函数有一个入参是 FunctionCallbackInfo，在 C++ 中可以通过这个对象拿到 JS 传来一些参数，这样就完成了 JS 层到 C++ 层通信。经过一系列处理之后，还是可以通过这个对象给 JS 层设置需要返回给 JS 的内容，这样可以完成了 C++ 层到 JS 层的通信。

现在有了底层能力，有了这一层的接口，但是我们是怎么去加载后执行 JS 代码呢?这时候就需要模块加载器

##  Node.js 中的模块加载器

Node.js 中有五种模块加载器。

1. JSON 模块加载器

2. 用户 JS 模块加载器

3. 原生 JS 模块加载器

4. 内置 C++ 模块加载器

5. Addon 模块加载器

现在来看下每种模块加载器。

### JSON 模块加载器

JSON 模块加载器实现比较简单，Node.js 从硬盘里面把 JSON 文件读到内存里面去，然后通过 JSON.parse 函数进行解析，就可以拿到里面的数据。

![image](https://user-images.githubusercontent.com/26076975/230344696-2ff667c4-f632-4096-b08c-595a94696fb6.png)

### 用户 JS 模块

![image](https://user-images.githubusercontent.com/26076975/230344757-29de28ae-7955-46cd-b731-43960ccfc90e.png)

用户 JS 模块就是我们平时写的一些 JS 代码。当通过 require 函数加载一个用户 JS 模块时，Node.js 就会从硬盘读取这个模块的内容到内存中，然后通过 V8 提供了一个函数叫 CompileFunctionInContext 把读取的代码封装成一个函数，接着新建立一个 Module 对象。这个对象里面有两个属性叫 exports 和 require 函数，这两个对象就是我们平时在代码里面所使用的变量，接着会把这个对象作为函数的参数，并且执行这个函数，执行完这个函数的时候，就可以通过 module.exports 拿到这个函数(模块)里面导出的内容。这里需要注意的是这里的 require 函数是可以加载原生 JS 模块和用户模块的，所以我们平时在我们代码里面，可以通过require 加载我们自己写的模块，或者 Node.js 本身提供的 JS 模块。

### 原生 JS 模块

![image](https://user-images.githubusercontent.com/26076975/230344850-24c0aa2c-0fc1-4e47-9381-fd9bd8358895.png)

接下来看下原生 JS 模块加载器。原生JS 模块是 Node.js 本身提供了一些 JS 模块，比如经常使用的 http 和 fs。当通过 require 函数加载 http 这个模块的时候，Node.js 就会从内存里读取这个模块所对应内容。因为原生 JS 模块默认是打包进内存里面的，所以直接从内存里面读就可以了，不需要从硬盘里面去读。然后还是通过 V8 提供的 CompileFunctionInContext 这个函数把读取的代码封装成一个函数，接着新建一个 NativeModule 对象，同样这个对象里面也是有个 exports 属性，接着它会把这个对象传到这个函数里面去执行，执行完这函数之后，就可以通过 module.exports 拿到这个函数里面导出的内容。需要注意是这里传入的 require 函数是一个叫 NativeModuleRequire 函数，这个函数它就只能加载原生 JS 模块。另外这里还传了另外一个 internalBinding 函数，这个函数是用于加载 C++ 模块的，所以在原生 JS 模块里面，是可以加载 C++ 模块的。

### C++ 模块
![image](https://user-images.githubusercontent.com/26076975/230344965-7ae7c23b-4668-488e-8167-387b4aa1ccda.png)

Node.js 在初始化的时候会注册 C++ 模块，并且形成一个 C++ 模块链表。当加载 C++ 模块时，Node.js 就通过模块名，从这个链表里面找到对应的节点，然后去执行它里面的钩子函数，执行完之后就可以拿到 C++ 模块导出的内容。

### Addon 模块
![image](https://user-images.githubusercontent.com/26076975/230345053-fdcc6109-123f-4b6f-a48d-2a100e744787.png)

接着再来看一下 Addon 模块， Addon 模块本质上是一个动态链接库。当通过 require 加载Addon 模块的时候，Node.js 会通过 dlopen 这个函数去加载这个动态链接库。

### Node.js 的服务器架构

下面从两个方面介绍 Node.js 的服务器架构

1. 介绍服务器处理 TCP 连接的模型

2. 介绍 Node.js 中的实现和存在的问题

#### 处理 TCP 连接的模型

首先来看一下网络编程中怎么去创建一个 TCP 服务器。

```
int fd = socket(…); 
bind(fd, 监听地址); 
listen(fd); 
```

首先建一个 socket， 然后把需要监听的地址绑定到这个 socket 中，最后通过 listen 函数启动服务器。启动服务器之后，那么怎么去处理 TCP 连接呢?

1). 串行处理(accept 和 handle 都会引起进程阻塞)

![image](https://user-images.githubusercontent.com/26076975/230352440-6e2e53eb-a929-4374-9b6a-766b88126e16.png)

第一种处理方式是串行处理，串行方式就是在一个 while 循环里面，通过 accept 函数不断地摘取 TCP 连接，然后处理它。这种方式的缺点就是它每次只能处理一个连接，处理完一个连接之后，才能继续处理下一个连接。

2). 多进程/多线程
![image](https://user-images.githubusercontent.com/26076975/230352493-4e48f390-a6b1-40d6-9fc1-44cf14e8c928.png)
第二种方式是多进程或者多线程的方式。这种方式主要是利用多个进程或者线程同时处理多个连接。但这种模式它的缺点就是当流量非常大的时候，进程数或者线程数它会成为这种架构下面的一个瓶颈，因为我们不能无限的创建进程或者线程，像 Apache 还有 PHP 就是这种架构的。

3). 单进程单线程 + 事件驱动( Reactor & Proactor ) 第三种就是单线程 + 事件驱动的模式。这种模式下有两种类型，第一种叫 Reactor， 第二种叫 Proactor。Reactor 模式就是应用程序可以通过事件驱动模块注册 fd 的读写事件，然后事件触发的时候，它就会通过事件驱动模块回调上层的代码。

![image](https://user-images.githubusercontent.com/26076975/230352768-83d7cd0a-8d87-42c6-af83-8beb5e5fd74a.png)


Proactor 模式就是应用程序可以通过事件驱动模块注册 fd 的读写完成事件，然后这个读写完成事件后就会通过事件驱动模块回调上层代码。

![image](https://user-images.githubusercontent.com/26076975/230352796-ffd22936-bce2-4178-a4fd-f7195250fedc.png)


我们看到这两种模式的区别是，数据读写是由内核完成的，还是由应用程序完成的。很显然，通过内核去完成是更高效的，但是因为 Proactor 这种模式它兼容性还不是很好，所以目前用的还不算太多，主要目前主流的一些服务器，它用的都是 Reactor 模式。比方说像 Node.js、Redis 和 Nginx 这些服务器用的都是这种模式。

刚才提到 Node.js 是单进程单线程加事件驱动的架构。那么单线程的架构它怎么去利用多核呢?这种时候就需要用到多进程的这种模式了，每一个进程里面会包含一个Reactor 模式。但是引入多进程之后，它会带来一个问题，就是多进程之间它怎么去监听同一个端口。

### Node.js 的实现和问题
下面来看下针对多进程监听同一个端口的一些解决方式。

1. 主进程监听端口并接收请求，轮询分发(轮询模式)

2. 子进程竞争接收请求(共享模式)

3. 子进程负载均衡处理连接(SO_REUSEPORT 模式)

第一种方式就是主进程去监听这个端口，并且接收连接。它接收连接之后，通过一定的算法(比如轮询)分发给各个子进程。这种模式。它的一个缺点就是当流量非常大的时候，这个主进程就会成为瓶颈，因为它可能都来不及接收或者分发这个连接给子进程去处理。

![image](https://user-images.githubusercontent.com/26076975/230352840-dcd0ba32-f7f3-41a0-911e-35a8d33cf938.png)


第二种就是主进程创建监听 socket， 然后子进程通过 fork 的方式继承这个监听的 socket， 当有一个连接到来的时候，操作系统就唤醒所有的子进程，所有子进程会以竞争的方式接收连接。这种模式，它的缺点主要是有两个，第一个就是负载均衡的问题，因为操作系统唤醒了所有的进程，可能会导致某一个进程一直在处理连接，其他其它进程都没机会处理连接。然后另外一个问题就是惊群的问题，因为操作系统唤起了所有的进程，但是只有一个进程它会处理这个连接，然后剩下进程就会被无效地唤醒。这种方式会造成一定的性能的损失。

![image](https://user-images.githubusercontent.com/26076975/230352862-1914f235-d250-451e-8316-c2f761d46014.png)


第三种通过 SO_REUSEPORT 这个标记来解决刚才提到的两个问题。在这种模式下，每个子进程都会有一个独立的监听 socket 和连接队列。当有一个连接到来的时候，操作系统会把这个连接分发给某一个子进程并且唤醒它。这样就可以解决惊群的问题，因为它只会唤醒一个子进程。又因为操作系统分发这个连接的时候，内部是有一个负载均衡的算法。所以这样的话又可以解决负载均衡的问题。

![image](https://user-images.githubusercontent.com/26076975/230352880-56bfb418-e780-4570-84d5-6d48f2d4278e.png)


接下来我们看一下 Node.js 中的实现。

1). 轮询模式。在这种模式下，主进程会 fork 多个子进程，然后每个子进程里面都会调用 listen 函数。但是 listen 函数不会监听一个端口，它会请求主进程监听这个端口，当有连接到来的时候，这个主进程就会接收这个连接，然后通过文件描述符的方式传给各个子进程去处理。

![image](https://user-images.githubusercontent.com/26076975/230352913-7656aa12-039e-45a2-adab-98245aca853e.png)


2). 共享模式 共享模式下，主进程同样还是会 fork 多个子进程，然后每个子进程里面还是会执行 listen 函数，但同样的这个 listen 函数不会监听一个端口，它会请求主进程创建一个 socket 并绑定到一个需要监听的地址，接着主进程会把这个 socket 通过文件描述符传递的方式传给多个子进程，这样就可以达到多个子进程同时监听同一个端口的效果。

![image](https://user-images.githubusercontent.com/26076975/230352918-37120360-f042-422f-b76c-e402af61f7f0.png)


通过刚才介绍，我们可以知道 Node.js 的服务器架构存在的问题。如果我们使用轮询模式，当流量比较大的时候，那么这个主进程就会成为系统瓶颈。如果我们使用共享模式，就会存在惊群和负载均衡的问题。不过在 Libuv 里面，可以通过设置 UV_TCP_SINGLE_ACCEPT 环境变量来一定程度缓解这个问题。当我们设置了这个环境变量。Libuv 在接收完一个连接的时候，它就会休眠一会，让其它进程也有接收连接的机会。

最后来总结一下，本文的内容。Node.js 里面通过 Libuv 解决了操作系统相关的问题。通过 V8 解决了执行 JS 和拓展 JS 功能的问题。通过模块加载器解决了代码加载还有组织的问题。通过多进程的服务器架构，使得 Node.js 可以利用多核，并且解决了多个进程监听同一个端口的问题。

### 进程和进程间通信

#### 创建进程
Node.js中的进程是使用fork+exec模式创建的，fork就是复制主进程的数据，exec是加载新的程序执行。Node.js提供了异步和同步创建进程两种模式。

1 异步方式

异步方式就是创建一个人子进程后，主进程和子进程独立执行，互不干扰。在主进程的数据结构中如图所示，主进程会记录子进程的信息，子进程退出的时候会用到
![image](https://user-images.githubusercontent.com/26076975/230350274-82b7acd0-849b-4e9c-bda2-d8a90170a474.png)
2 同步方式
![image](https://user-images.githubusercontent.com/26076975/230350389-25cbe5db-8911-42a7-95d6-35e1021fe88a.png)

同步创建子进程会导致主进程阻塞，具体的实现是

1 主进程中会新建一个新的事件循环结构体，然后基于这个新的事件循环创建一个子进程。

2 然后主进程就在新的事件循环中执行，旧的事件循环就被阻塞了。

3 子进程结束的时候，新的事件循环也就结束了，从而回到旧的事件循环。

#### 进程间通信

接下来我们看一下父子进程间怎么通信呢？在操作系统中，进程间的虚拟地址是独立的，所以没有办法基于进程内存直接通信，这时候需要借助内核提供的内存。进程间通信的方式有很多种，管道、信号、共享内存等等。


Node.js选取的进程间通信方式是Unix域，Node.js为什么会选取Unix域呢？因为只有Unix域支持文件描述符传递。文件描述符传递是一个非常重要的能力。

首先我们看一下文件系统和进程的关系，在操作系统中，当进程打开一个文件的时候，他就是形成一个fd file inode这样的关系，这种关系在fork子进程的时候会被继承。
![image](https://user-images.githubusercontent.com/26076975/230350891-1be89f5c-8b00-48ac-92eb-558935e1ca22.png)
但是如果主进程在fork子进程之后，打开了一个文件，他想告诉子进程，那怎么办呢？如果仅仅是把文件描述符对应的数字传给子进程，子进程是没有办法知道这个数字对应的文件的。如果通过Unix域发送的话，系统会把文件描述符和文件的关系也复制到子进程中。

#### 线程和线程间通信

线程架构

Node.js是单线程的，为了方便用户处理耗时的操作，Node.js在支持多进程之后，又支持了多线程。Node.js中多线程的架构如下图所示。每个子线程本质上是一个独立的事件循环，但是所有的线程会共享底层的Libuv线程池。


创建线程

接下来我们看看创建线程的过程

![image](https://user-images.githubusercontent.com/26076975/230351042-64cffb95-4dd6-4b29-b7ee-1f1f1d2a38f1.png)

当我们调用new Worker创建线程的时候

1 主线程会首先创建创建两个通信的数据结构，接着往对端发送一个加载js文件的消息。

2 然后调用底层接口创建一个线程。

3 这时候子线程就被创建出来了，子线程被创建后首先初始化自己的执行环境和上下文。

4 接着从通信的数据结构中读取消息，然后加载对应的js文件执行，最后进入事件循环。

线程间通信

那么Node.js中的线程是如何通信的呢？线程和进程不一样，进程的地址空间是独立的，不能直接通信，但是线程的地址是共享的，所以可以基于进程的内存直接进行通信。

![image](https://user-images.githubusercontent.com/26076975/230351151-a422222c-0d79-407b-a580-31f35574ff18.png)

下面我们看看Node.js是如何实现线程间通信的。了解Node.js线程间通信之前，我们先看一下一些核心数据结构。

1 Message代表一个消息。

2 MessagePortData是对操作Message的封装和对消息的承载。

3 MessagePort是代表通信的端点，是对MessagePortData的封装。

4 MessageChannel是代表通信的两端，即两个MessagePort。

![image](https://user-images.githubusercontent.com/26076975/230351202-e9e7f30f-2336-4b13-bfd4-8cb6ee134880.png)

我们看到两个port是互相关联的，当需要给对端发送消息的时候，只需要往对端的消息队列插入一个节点就行。

我们来看看通信的具体过程

1 线程1调用postMessage发送消息。

2 postMessage会先对消息进行序列化。

3 然后拿到对端消息队列的锁，并把消息插入队列中。

4 成功发送消息后，还需要通知消息接收者所在的线程。

5 消息接收者会在事件循环的poll io阶段处理这个消息。

## 信号

![image](https://user-images.githubusercontent.com/26076975/230351578-12fc5485-0bda-4944-a73c-b2d2e06ee4e3.png)

上图是操作系统中信号的表示，操作系统使用一个long类型表示进程收到的信息，并且用一个数组来标记对应的处理函数。

我们看一下信号在Libuv中是如何实现的。

![image](https://user-images.githubusercontent.com/26076975/230351616-cb0f4c48-44d9-4279-9cb1-350e94ec43b0.png)

1 Libuv中维护了一个红黑树，当我们监听一个新的信号时就会新插入一个节点

2 在插入第一个节点时，Libuv会封装一个io观察者注册到epoll中，用来监听是否有信号需要处理

3 当信号发生的时候，就会根据信号类型从红黑树中找到对应的handle，然后通知主线程

4 主线程在poll io阶段就会逐个执行回调。

Node.js中，是通过监听newListener事件来实现信号的监听的，newListener是一种hooks的机制。每次监听事件的时候，如果监听了该事件，那就会触发newListener事件。所以当执行process.on(’SIGINT’)时，就会调用startListeningIfSignal注册一个红黑树节点。 并在events模块保存了订阅关系，信号触发时，执行process.emit(‘SIGINT’)通知订阅者。

![image](https://user-images.githubusercontent.com/26076975/230351663-76cd80d2-4e35-4254-851e-f5d633258354.png)


## 文件

文件操作

Node.js中文件操作分为同步和异步模式，同步模式就是在主进程中直接调用文件系统的api，这种方式可能会引起进程的阻塞，异步方式是借助了Libuv线程池，把阻塞操作放到子线程中去处理，主线程可以继续处理其他操作。

![image](https://user-images.githubusercontent.com/26076975/230351760-e7f39d85-7cdd-456c-9b90-184a340d9684.png)

文件监听

Node.js中文件监听提供了基于轮询和订阅发布两种模式。我们先看一下轮询模式的实现，轮询模式比较简单，他是使用定时器实现的，Node.js会定时执行回调，在回调中比较当前文件的元数据和上一次获取的是否不一样，如果是则说明文件改变了。


![image](https://user-images.githubusercontent.com/26076975/230351804-76e8e557-e4c9-4df1-949f-da0c2b538af0.png)

第二种监听模式是更高效的inotify机制，inotify是基于订阅发布模式的，避免了无效的轮询。我们首先看一下操作系统的inotify机制，inotify和epoll的使用是类似的

1 首先通过接口获取一个inotify实例对应的文件描述符。

2 然后通过增删改查接口操作inotify实例，比如需要监听一个文件的时候，就调用接口往inotify实例中新增一个订阅关系。

3 当文件发生改变的时候，我们可以调用read接口获取哪些文件发生了改变，inotify通常结合epoll来使用。

接下来我们看看Node.js中是如何基于inotify机制 实现文件监听的。

![image](https://user-images.githubusercontent.com/26076975/230351847-313a1544-9b5c-4414-86a3-a956452f2f76.png)

1 首先Node.js把inotify实例的文件描述符和回调封装成io观察者注册到epoll中

2 当需要监听一个文件的时候，Node.js会调用系统函数往inotify实例中插入一个项，并且拿到一个id，接着Node.js把这个id和文件信息封装到一个结构体中，然后插入红黑树。

3 Node.js维护了一棵红黑树，红黑树的每个节点记录了被监听的文件或目录和事件触发时的回调列表。

4 如果有事件触发时，在poll io阶段就会执行对应的回调，回调里会判断哪些文件发生了变化，然后根据id从红黑树中找到对应的接口，从而执行对应的回调。



